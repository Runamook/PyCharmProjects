import datetime
from time import sleep
import re
import pytz

# try:
#     from .emhmeter import MeterBase, create_input_vars, logger
# except ModuleNotFoundError:
#     from emhmeter import MeterBase, create_input_vars, logger

# TODO: Not working


class GetTime:

    def __init__(self, input_vars):
        self.input_vars = input_vars
        self.meter_number = input_vars["meter"]["meterNumber"]
        self.results = dict()

    def _get(self, what):
        # results = dict()
        # Get time
        if what == "time":
            obis = "0.9.1"
            name = "time"
        elif what == "date":
            obis = "0.9.2"
            name = "date"
        else:
            logger.error(f"Incorrect input {what}, use \"time\" or \"date\"")
            raise KeyError

        delta = datetime.timedelta(seconds=14)
        ref_time = datetime.datetime.utcnow() + delta
        self.results[name] = [ref_time, None]
        logger.debug(f"===================== Getting {name} ===================== ")
        value = self.query("R5", f"{obis}()")
        if obis not in value:
            logger.error(f"Unable to receive {name}. Received: \"{value}\"")
            value = f"{obis}(error)"
        self.results[name][1] = value
        logger.debug(f"{self.results}")
        if what == "time":
            self.make_pause()
        return

    def query(self, cmd, data):
        with MeterBase(self.input_vars) as m:
            m.sendcmd_and_decode_response(b"/" + b"?" + self.meter_number.encode() + b"!\r\n")
            m.sendcmd_and_decode_response(MeterBase.ACK + b'051\r\n')
            result = m.sendcmd_and_decode_response(cmd.encode(), data.encode())
            cmd = MeterBase.SOH + b'B0' + MeterBase.ETX
            m.sendcmd_and_decode_response(cmd + MeterBase.bcc(cmd))
            return result

    @staticmethod
    def make_pause():
        pause = 25
        logger.debug(f"Pausing for {pause} seconds")
        sleep(pause)
        return

    def check(self, what, value):

        # 0.9.2(1190724), 0.9.1(1221856)
        re_in_parenthesis = re.compile('^0.9..[(](.+?)[)]')
        logger.debug(f"Checking meter {what} \"{value}\"")

        reference_value = value[0]
        checked_value = value[1]

        found_value = re_in_parenthesis.search(checked_value).groups()[0]

        if what == "date":
            return self.check_date(reference_value, found_value)
        elif what == "time":
            return self.check_time(reference_value, found_value)

    @staticmethod
    def check_date(ref_value, checked_value):
        # datetime object, string
        if checked_value != "error":
            ref_value = ref_value.strftime("%y%m%d")
        else:
            ref_value = "010000"
        checked_value = checked_value[1:]
        logger.debug(f"Checking {ref_value} == {checked_value}")
        return ref_value == checked_value

    @staticmethod
    def check_time(ref_value, checked_value):
        # datetime object, string

        # Select meter TZ based on response
        if checked_value[0] == "1":
            local_tz = pytz.timezone("Europe/Berlin")  # UTC +2
        elif checked_value[0] == "2":
            local_tz = pytz.timezone("UTC")
        else:
            local_tz = pytz.timezone("Europe/Moscow")  # UTC +3

        # Generate "now" time in UTC
        utc_now = pytz.utc.localize(datetime.datetime.utcnow())

        # ref_value is UTC already, insert TZ info into object
        ref_value = pytz.utc.localize(ref_value)
        # Adjust it to actual meter TZ
        ref_value = ref_value.astimezone(local_tz)

        if checked_value != "error":
            now_date = utc_now.strftime("%y%m%d")
        else:
            now_date = "010000"

        # Take meter TZ now date (generated by script), add to meter TZ now time (received from meter)
        checked_value = datetime.datetime.strptime(now_date + checked_value[1:], "%y%m%d%H%M%S")
        # Insert local_tz into datetime object
        checked_value = local_tz.localize(checked_value)

        # Now both objects are in local TZ
        logger.debug(f"Checking {ref_value} == {checked_value}")

        # Compare
        delta = (checked_value - ref_value).total_seconds()
        logger.debug(f"Delta = {delta}")

        allowable_delta = 6  # Seconds
        return abs(delta) <= allowable_delta

    def get(self):

        self.input_vars["get_id"] = False

        self._get("time")
        self._get("date")

        for key in self.results.keys():
            if self.check(key, self.results[key]):
                logger.debug(f"{key} is correct")
                self.results[key].append("0")
            else:
                logger.debug(f"{key} is incorrect")
                self.results[key].append("1")

        return self.results

    def parse(self, data):
        # Input
        # {'time': [datetime.datetime(2019, 7, 27, 13, 43, 28, 274370), '0.9.1(1154336)', '0'],
        # 'date': [datetime.datetime(2019, 7, 27, 13, 44, 20, 519825), '0.9.2(1190727)', '1']},

        logger.debug(f"{self.meter_number} Parsing time output")
        logger.debug(f"{self.meter_number} {data}")

        results = dict()

        for key in data.keys():
            if key == "time":
                obis = "0.9.1"
            elif key == "date":
                obis = "0.9.2"

            epoch = data[key][0].strftime("%s")
            item_value = data[key][1]
            trigger_value = data[key][2]

            results[epoch] = [(f"{obis}-value", item_value), (f"{obis}-trigger", trigger_value)]

        # {epoch: [(obis_code, val), (), (), ...]}

        final_result = {"time": results}
        logger.debug(f"{final_result}")
        return final_result


if __name__ == "__main__":
    meter = {
        "meterNumber": "04180616",
        "Manufacturer": "",
        "ip": "10.124.2.48",
        "InstallationDate": "2018-10-10T10:00:00",
        "IsActive": True,
        "voltageRatio": 200,
        "currentRatio": 10,
        "totalFactor": 210
    }

    meter = {
        "meterNumber": "05296170",
        "Manufacturer": "EMH",
        "ip": "10.124.2.120",
        "InstallationDate": "2019-02-20T09:00:00",
        "IsActive": True,
        "voltageRatio": 200,
        "currentRatio": 15,
        "totalFactor": 215
    }

    variables = {"port": MeterBase.get_port(meter["ip"]),
                 "timestamp": MeterBase.get_dt(),
                 "data_handler": "P.01",
                 "exporter": "Zabbix",
                 "server": "192.168.33.33",
                 "meter": meter
                 }

    logger.setLevel("DEBUG")

    m = GetTime(variables)
    data = m.get()
    print(m.parse(data))
